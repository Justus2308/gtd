const std = @import("std");
const stdx = @import("stdx");
const zalgebra = @import("zalgebra");
const domath = @import("domath");

const math = std.math;
const mem = std.mem;
const sort = std.sort;

const Allocator = mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const PathBuilder = stdx.splines.PathBuilder;
const Vec2 = zalgebra.Vec2;

const assert = std.debug.assert;

// Maps are always 4:3
pub const horizontal_segment_count = 40;
pub const vertical_segment_count = 30;
pub const total_segment_count = (horizontal_segment_count * vertical_segment_count);

pub const x_min = 0.0;
pub const x_max = 4.0;
pub const y_min = 0.0;
pub const y_max = 3.0;

pub const xy_min = Vec2.zero();
pub const xy_max = Vec2.new(x_max, y_max);

pub const Segment = struct {
    from: f32,
    to: f32,

    pub fn register(segment: *Segment, t: f32) void {
        segment.from = @min(segment.from, t);
        segment.to = @max(segment.to, t);
    }
};

// goals:
// - construct mapping from entity t to segment id
// - construct mapping from projectile xy to segment id
//
// 2d points on path + corresponding t (generated by PathBuilder)
// -> total_segment_count segments with from..to t ranges
// -> active segments sorted by from t with corresp. segment id
//
// xy -> segment is trivial
//
// active segments are sparse
// -> construct mapping from segment id to active segment location
// -> segment id -> u16 idx -> projectile entry set

/// Draw a circle with `max_entity_radius` around every point on the discretized path and
/// mark every segment intersected/enclosed by that circle.
pub fn fromDiscretizedPath(
    noalias dest: *[horizontal_segment_count][vertical_segment_count]Segment,
    discretized: PathBuilder.Subpath.Discretized.Slice,
    max_entity_radius: f32,
) void {
    var active_segments: [horizontal_segment_count]std.StaticBitSet(vertical_segment_count) = @splat(.initEmpty());
    comptime assert(@sizeOf(@TypeOf(active_segments)) < (1 << 10)); // prevent accidental stack overflow if we change seg count

    const min_angle = (0.9 * math.acos(@as(f32, 1.0) - (@as(f32, 1.0) / max_entity_radius)));

    for (discretized.items(.coords), discretized.items(.t)) |coord, t| {
        // 'draw' circle, https://stackoverflow.com/a/58629898/20378526
        var angle: f32 = 0.0;
        while (angle <= 360.0) : (angle += min_angle) {
            const offset = Vec2.new(@sin(angle), @cos(angle)).scale(max_entity_radius);
            const point = clampToWorldSpace(coord.asVec().add(offset));
            const hv_seg = hash(point);
            active_segments[hv_seg.x()].set(hv_seg.y());
        }
        // 'fill in' circle
        for (&active_segments, 0..) |*active_v_segs, h_seg| {
            const first_v_seg = active_v_segs.findFirstSet() orelse continue;
            const last_v_seg = active_v_segs.findLastSet().?;

            var v_seg: usize = first_v_seg;
            while (v_seg <= last_v_seg) : (v_seg += 1) {
                dest[h_seg][v_seg].register(t);
            }

            active_v_segs.unsetAll();
        }
    }
}

fn clampToWorldSpace(vector: Vec2) Vec2 {
    return vector.max(xy_min).min(xy_max);
}

/// R x R - - > 0..horizontal_seg_count x 0..vertical_seg_count ----> 0..total_seg_count
fn hashLinear(point: Vec2) u16 {
    const hv_seg = hash(point);
    const hashed = ((hv_seg.x() * vertical_segment_count) + hv_seg.y());
    assert(hashed >= 0 and hashed < total_segment_count);
    return hashed;
}

fn hash(point: Vec2) zalgebra.GenericVector(2, u16) {
    const hv_norm = point.norm().mul(xy_max);
    const hv_seg = hv_norm.mul(comptime .new(horizontal_segment_count, vertical_segment_count)).cast(u16);
    assert(hv_seg.x() < horizontal_segment_count and hv_seg.y() < vertical_segment_count);
    return hv_seg;
}

// Data flow:
// raw points on path -> calc segment for every point, create event for every segment change

pub const Event = struct {
    value: f32,
    id: u32,

    pub fn lessThan(_: void, a: Event, b: Event) bool {
        return (a.value < b.value);
    }
};

// TODO move
pub const Window = struct {
    width: f32,
    height: f32,

    width_normalized: f32,
    height_normalized: f32,

    horizontal_segment_count: u32,
    vertical_segment_count: u32,

    total_segment_count: u32,

    pub fn init(width: f32, height: f32, horizontal_segment_count: f32, vertical_segment_count: f32) Window {}

    // consider passing arena as allocator and reusing arena for every subpath
    pub fn createEvents(self: Window, allocator: Allocator, path: []const Vec2D, max_entity_radius: f32) Allocator.Error![]const Event {
        var active_segments = try std.bit_set.DynamicBitSetUnmanaged.initEmpty(allocator, self.total_segment_count);
        defer active_segments.deinit(allocator);

        var events = std.ArrayListUnmanaged(Event).empty;
        errdefer events.deinit(allocator);

        var event_starts = try allocator.alloc(f32, self.total_segment_count);
        defer allocator.free(event_starts);
        @memset(event_starts, -1.0);

        // PLAN: populate new bitset for every point, cmp to current bitset, create events for all diffs, set current bitset to new bitset
        // solve with single iteration?

        const min_angle = ((0.9 * math.acos(@as(f32, 1.0)) - (@as(f32, 1.0) / max_entity_radius)));

        for (path, 0..) |p, i| {
            // 'draw' circle, https://stackoverflow.com/a/58629898/20378526
            var angle: f32 = 0.0;
            while (angle <= 360.0) : (angle += min_angle) {
                const q = Vec2D{
                    .x = max_entity_radius * @cos(angle),
                    .y = max_entity_radius * @sin(angle),
                };
                const seg = self.hash(p.add(q));
                event_starts[seg] = i;
            }

            // 'fill' circle and register identified segments
            var iter = active_segments.iterator(.{});

            var curr = iter.next() orelse continue;
            var curr_hseg: usize = curr % self.vertical_segment_count;

            while (iter.next()) |next| {
                const hseg = next % self.vertical_segment_count;
                // TODO rewrite logic to directly generate events
                if (curr_hseg == hseg) {
                    for (curr..(next + 1)) |seg| {
                        b.can_collide[seg].set(i);
                        event_starts[seg] = {};
                    }
                } else {
                    b.can_collide[curr].set(i);
                }
                curr = next;
                curr_hseg = hseg;
            }
        }

        const owned = try events.toOwnedSlice(allocator);
        return owned;
    }

    fn hashMany(
        comptime batch_size: comptime_int,
        noalias x_in: *const [batch_size]f32,
        noalias y_in: *const [batch_size]f32,
        noalias out: *[batch_size]u16,
    ) void {
        const v2 = domath.vectorEx(2, f32, .{ .batch_size = batch_size });
        const v1 = domath.vectorEx(1, u16, .{ .batch_size = batch_size });

        // Declare buffers to store intermediary results
        var buf1: v2.Slicable = undefined;
        var buf2: v2.Slicable = undefined;
        var buf_int: v1.Slicable = undefined;

        const hv_norm = v2.slices(&buf1);

        v2.normalize(&.{ x_in, y_in }, &hv_norm);

        const h_seg_count = v2.splatScalar(horizontal_segment_count);
        const v_seg_count = v2.splatScalar(vertical_segment_count);

        const hv_seg = v2.slices(&buf2);

        v2.mul(&hv_norm, &.{ &h_seg_count, &v_seg_count }, &hv_seg);

        const h_seg_int = v1.slices(&buf_int);
        v2.single_dim.cast(u16, &.{v2.extractDim(hv_seg, .x)}, &h_seg_int);

        const v_seg_count_int = v1.splatScalar(vertical_segment_count);

        var accu = v1.Accumulator.begin(.scale, &h_seg_int, .{&v_seg_count_int});
        accu.end(.add, .{&v_seg_count_int}, &.{out});
    }
};
