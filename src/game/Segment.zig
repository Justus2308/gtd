from: f32,
to: f32,

const Segment = @This();

pub const Map = struct {
    segments: [horizontal_segment_count][vertical_segment_count]Segment,

    // Maps are always 4:3
    pub const horizontal_segment_count = 40;
    pub const vertical_segment_count = 30;
    pub const total_segment_count = (horizontal_segment_count * vertical_segment_count);

    pub const x_min = 0.0;
    pub const x_max = 4.0;
    pub const y_min = 0.0;
    pub const y_max = 3.0;

    pub const xy_min = Vec2.zero();
    pub const xy_max = Vec2.new(x_max, y_max);

    pub fn getIndices(comptime ns2: type, noalias in: *const [2]*const ns.Scalars, noalias out: *ns.casted(u16).Scalars) void {
        const ns = domath.v2f32;

        const buf_xy_max: ns.Slicable = .{ ns.splatScalar(x_max * horizontal_segment_count), ns.splatScalar(y_max * vertical_segment_count), };
        const in_xy_max = ns.slices(&buf_xy_max);

        var accu = ns.Accumulator.begin(.normalize, in, .{});
        accu.cont(.mul, .{&in_xy_max});
        var accu_indices = accu.cast(u16);
        accu_indices.end(comptime op: Op, noalias extra_args: (unknown type), noalias out: (unknown type))
    }

    /// Draw a circle with `max_entity_radius` around every point on the discretized path and
    /// mark every segment intersected/enclosed by that circle.
    pub fn fillFromDiscretizedPath(
        noalias map: *Segment.Map,
        discretized: PathBuilder.Subpath.Discretized.Slice,
        max_entity_radius: f32,
    ) void {
        var active_segments: [horizontal_segment_count]std.StaticBitSet(vertical_segment_count) = @splat(.initEmpty());
        comptime assert(@sizeOf(@TypeOf(active_segments)) < (1 << 10)); // prevent accidental stack overflow if we change seg count

        const min_angle = (0.9 * math.acos(@as(f32, 1.0) - (@as(f32, 1.0) / max_entity_radius)));

        for (discretized.items(.coords), discretized.items(.t)) |coord, t| {
            // 'draw' circle, https://stackoverflow.com/a/58629898/20378526
            var angle: f32 = 0.0;
            while (angle <= 360.0) : (angle += min_angle) {
                const offset = Vec2.new(@sin(angle), @cos(angle)).scale(max_entity_radius);
                const point = clampToWorldSpace(coord.asVec().add(offset));
                const hv_seg = hash(point);
                active_segments[hv_seg.x()].set(hv_seg.y());
            }
            // 'fill in' circle
            for (&active_segments, 0..) |*active_v_segs, h_seg| {
                const first_v_seg = active_v_segs.findFirstSet() orelse continue;
                const last_v_seg = active_v_segs.findLastSet().?;

                var v_seg: usize = first_v_seg;
                while (v_seg <= last_v_seg) : (v_seg += 1) {
                    const segment = &map.segments[h_seg][v_seg];
                    segment.from = @min(segment.from, t);
                    segment.to = @max(segment.to, t);
                }

                active_v_segs.unsetAll();
            }
        }
    }

    fn clampToWorldSpace(vector: Vec2) Vec2 {
        return vector.max(xy_min).min(xy_max);
    }

    fn hash(point: Vec2) zalgebra.GenericVector(2, u16) {
        const hv_norm = point.norm().mul(xy_max);
        const hv_seg = hv_norm.mul(comptime .new(horizontal_segment_count, vertical_segment_count)).cast(u16);
        assert(hv_seg.x() < horizontal_segment_count and hv_seg.y() < vertical_segment_count);
        return hv_seg;
    }
};

// goals:
// - construct mapping from entity t to segment id
// - construct mapping from projectile xy to segment id
//
// 2d points on path + corresponding t (generated by PathBuilder)
// -> total_segment_count segments with from..to t ranges
// -> active segments sorted by from t with corresp. segment id
//
// xy -> segment is trivial
//
// active segments are sparse
// -> construct mapping from segment id to active segment location
// -> segment id -> u16 idx -> projectile entry set

const std = @import("std");
const stdx = @import("stdx");
const zalgebra = @import("zalgebra");
const domath = @import("domath");

const math = std.math;
const mem = std.mem;
const sort = std.sort;

const Allocator = mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const PathBuilder = stdx.splines.PathBuilder;
const Vec2 = zalgebra.Vec2;

const assert = std.debug.assert;
